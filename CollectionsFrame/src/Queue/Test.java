package Queue;

import java.util.Queue;
import java.util.concurrent.ArrayBlockingQueue;

/**
 * Первый объект помещенный в очередь будет первым и на выход. FIFO-first in,first out
 *
 *
 * В случае ошибки выбрасывают исключение(exception)
 * Метод add() добавляет объект в очередь
 * Метод remove() удаляет объект из очереди.
 * Метод element() тоже показывает первый объект в очереди
 *
 *
 * В случае ошибки выдают специальное значение (true,false)
 * Метод offer() так же добавляет объект в очередь
 * Метод poll() тоже удаляет объект из очереди.
 * Метод peek() показывает первый объект в очереди.
 *
 * Они одинаковы. Выбираем что удобно в конкретной ситуации.
 *
 *
 *
 *
 *
 *
 * PriorityQueue - это класс, реализующий interface Queue, поэтому он обладает всеми характеристиками
 * очереди и поддерживает все опциональные операции of Collection. Однако, в отличие от обычной очереди,
 * элементы of PriorityQueue сортируются в порядке возрастания на основе их естественного порядка или в
 * соответствии с предоставленным Comparator (в зависимости от используемого конструктора), поэтому,
 * когда новый элемент вставляется в PriorityQueue, он может находиться не в последней позиции.
 * PriorityQueue - это асинхронная очередь, поэтому вы не должны использовать ее в среде multithreading,
 * вместо этого используйте потокобезопасный (thread-safe) класс PriorityBlockingQueue.
 *
 *
 * В ArrayBlockingQueue мы можем указать максимальный размер нашей очереди.Если 10,то будет 10 и не более.
 *
 *
 *
 *
 * Интерфейс Deque
 * Интерфейс Deque расширяет вышеописанный интерфейс Queue и определяет поведение двунаправленной очереди,
 * которая работает как обычная однонаправленная очередь, либо как стек, действующий
 * по принципу LIFO (последний вошел - первый вышел).
 *
 * void addFirst(E obj): добавляет элемент в начало очереди
 *
 * void addLast(E obj): добавляет элемент obj в конец очереди
 *
 * E getFirst(): возвращает без удаления элемент из головы очереди.
 * Если очередь пуста, генерирует исключение NoSuchElementException
 *
 * E getLast(): возвращает без удаления последний элемент очереди.
 * Если очередь пуста, генерирует исключение NoSuchElementException
 *
 * boolean offerFirst(E obj): добавляет элемент obj в самое начало очереди.
 * Если элемент удачно добавлен, возвращает true, иначе - false
 *
 * boolean offerLast(E obj): добавляет элемент obj в конец очереди.
 * Если элемент удачно добавлен, возвращает true, иначе - false
 *
 * E peekFirst(): возвращает без удаления элемент из начала очереди.
 * Если очередь пуста, возвращает значение null
 *
 * E peekLast(): возвращает без удаления последний элемент очереди.
 * Если очередь пуста, возвращает значение null
 *
 * E pollFirst(): возвращает с удалением элемент из начала очереди.
 * Если очередь пуста, возвращает значение null
 *
 * E pollLast(): возвращает с удалением последний элемент очереди.
 * Если очередь пуста, возвращает значение null
 *
 * E pop(): возвращает с удалением элемент из начала очереди.
 * Если очередь пуста, генерирует исключение NoSuchElementException
 *
 * void push(E element): добавляет элемент в самое начало очереди
 *
 * E removeFirst(): возвращает с удалением элемент из начала очереди.
 * Если очередь пуста, генерирует исключение NoSuchElementException
 *
 * E removeLast(): возвращает с удалением элемент из конца очереди.
 * Если очередь пуста, генерирует исключение NoSuchElementException
 *
 * boolean removeFirstOccurrence(Object obj): удаляет первый встреченный элемент obj из очереди.
 * Если удаление произшло, то возвращает true, иначе возвращает false.
 *
 * boolean removeLastOccurrence(Object obj): удаляет последний встреченный элемент obj из очереди.
 * Если удаление произшло, то возвращает true, иначе возвращает false.
 *
 * Таким образом, наличие методов pop и push позволяет классам, реализующим этот элемент,
 * действовать в качестве стека. В тоже время имеющийся функционал также позволяет создавать
 * двунаправленные очереди, что делает классы, применяющие данный интерфейс, довольно гибкими.
 *
 *
 */
public class Test {
    public static void main(String[] args) {
        Person person1 = new Person(1);
        Person person2 = new Person(2);
        Person person3 = new Person(3);
        Person person4 = new Person(4);

        Queue<Person> people = new ArrayBlockingQueue<Person>(10);
        people.add(person3);
        people.add(person2);
        people.add(person4);
        people.add(person1);

       /* for (Person person : people)
            System.out.println(person);*/ //выводится в порядке заполнения очереди. 3-2-4-1
        System.out.println(people.remove());//remove() удаляет объект в голове нашего списка. 1
        System.out.println(people.peek());//просто покажет 1 объект в очереди ничего не делая с ним
        System.out.println(people);


    }
}

class Person{
    private int id;

    public Person(int id) {
        this.id = id;
    }

    @Override
    public String toString() {
        return "Person{" +
                "id=" + id +
                '}';
    }
}
