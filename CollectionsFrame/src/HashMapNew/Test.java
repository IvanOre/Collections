package HashMapNew;

import java.util.HashMap;
import java.util.Map;

/**
 *                   <<interface>>
 *                        Map
 * _________________________________________________
 * |           |                 |               |
 * Hashtable     LinkedHashMap      HashMap       <<interface>>
 *                                                  SortedMap
 *                                                       |
 *                                                     TreeMap
 *
 *
 *
 * Map по популярности не уступает List(2 место) Самый полезный HashMap
 * Map переводится как отображение.Более уместно тут
 * Есть 2 множества и мы элементы 1 множества сопоставляем элементам 2 множества
 * Например 2 таблицы. в 1 классы школы и им сопоставляется 2 таблица, где ученики школы
 * <p>
 * Map<K,V> map = new HashMap<>(); мапа хронит ключ-значение
 * <> указываем для корректного отображения,что бы хранились объекты указанные слева
 * а не просто объекты класса Object
 *
 * Должны указать ключ K и значение V
 *
 *         map.put(1, "Один");     что бы добавить в мапу используем put()
 *         map.put(2, "Два");
 *         map.put(3, "Три");
 *
 *         map.put(3,"Другое значение для ключа 3");
 * если вставляем в ключ существующий новое значение для него,то он просто перезаписывается новым значением.
 * Дубликатов быть не может
 *
 * Но может быть одинаковое значение.
 *
 * каждая пара ключ-значение в жаве это entry. Не рассматриваются отдельно. А как единое целое
 * ключ-значение=entry
 *
 * У класса HashMap есть важная особенность. Элементы т.е пары ключ-значение не имеют какого-либо порядка
 * Класс HashMap не гарантирует какого-либо порядка. Вывод может быть 1.2.3.4.5 а 2.5.1.3.4 например.
 * Используем HashMap если нам не важен порядок, а главное наличие ключ-значение. Если нужен порядок, то лучше
 * использовать другие классы реализующие Map
 *
 *
 *
 *
 *                           Как устроен HashMap
 *
 * HashMap внутри себя использует массив.В каждой ячейке массива хранится связный список. Позволяет очень быстро
 * выполнять операции put(добавление пары ключ-значение) и операцию get(получение пары ключ-значение по ключу)
 * Node<K,V>[] table--> int hash; K key; V value; Node<K,V> next;
 * По сути как ЛинкедЛист.
 *
 *
 * У элементов есть хеш. например 256946. Оно больше чем наш массив 16 элементов. Поэтому что бы получить
 * допустимое значение ,используется побитовое умножение или остаток от деления целочисленного. Получается индекс.
 * Допустим 4. И это значение кладем в этот индекс в нашем массиве.
 * index = hash & (n-1)   n=16.
 *
 * 4 как пример индекса.
 *Если при выполнении операции для следующего хеша,получается такой же индекс(4) ,в котором уже лежит значение,то
 * мы добавляем этот элемент в конец связного списка индекса 4.
 *
 *
 *
 * Теперь как будет работать get
 *
 * Индекс получаемого элемента высчитывается так же.Не нужно проходится по всему списку. Высчитывается хешкод
 * V get (Object key)
 * hash (key)
 * index = hash & (n-1)
 *
 * Если в индексе лежит несколько элементов?
 * Так же высчитывается через хеш его индекс и начинает сравниваться ключ и его хешкод.Если хеши равны,это
 * значит либо ключи равны, либо коллизия.
 *
 * Если же хотим получить элемент который лежит в самом конце индекса связного списка. Делается тоже самое
 * высчитывется хеш,попадаем в нужный индекс,там связный список элементов в котором лежит наш искомый элемент,
 * мы начинаем сравнивать хеши элементов искомого и всех которые лежат в этом индексе. Первый элемент берем,
 * смотрим хеши,не равны,идем дальше даже не проверяя через equals,второй элемент проверяем хеши,тоже не равны,
 * идем дальше и так пока не найдем наш искомый элемент.Совпадение по хешу и по еквалс.
 *
 * С помощью хеширования очень быстро проводятся операции get and put.
 *
 *
 */
public class Test {
    public static void main(String[] args) {
        Map<Integer, String> map = new HashMap<>();//<> указываем что бы синтаксис был корректен

        map.put(1, "Один");// что бы добавить в мапу используем put()
        map.put(2, "Два");
        map.put(3, "Три");
        map.put(4, "Четыре");
        map.put(5, "Пять");

// каждая пара ключ-значение в жаве это entry. Не рассматриваются отдельно. А как единое целое/ ключ-значение=entry
        for (Map.Entry<Integer,String> entry : map.entrySet()){//получаем мапу-параметризуем-даем имя entry :
            // : вызываем метод entrySet() он возвращает набор всех пар ключ-значение в нашей мапе
            System.out.println(entry.getKey() + " : " + entry.getValue());

        }



       /* System.out.println(map);
        map.put(3,"Другое значение для ключа 3");// если вставляем в ключ существующий новое значение для него,
        // то он просто перезаписывается
        System.out.println(map);

        System.out.println(map.get(2));// через команду get() получаем значение по ключу
        System.out.println(map.get(10));//если укажем несуществующий ключ, то вернется null*/


    }

}

